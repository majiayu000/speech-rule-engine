/**
 * @file Japanese mathspeak utility functions.
 * @author Generated by AI Assistant
 */

import { LOCALE } from '../l10n/locale.js';
// import { DynamicCstr } from '../rule_engine/dynamic_cstr.js';
import { BaseRuleStore } from '../rule_engine/base_rule_store.js';
import { AuditoryDescription } from '../audio/auditory_description.js';
import { Action, SpeechRule } from '../rule_engine/speech_rule.js';
import { Span } from '../audio/span.js';

// Store for Japanese mathspeak rules
class JapaneseRuleStore extends BaseRuleStore {
  constructor() {
    super();
  }

  // 实现抽象类必需的方法
  public evaluateDefault(node: Node): AuditoryDescription[] {
    const text = node.textContent || '';
    return [AuditoryDescription.create({ text })];
  }

  public evaluateString(str: string): AuditoryDescription[] {
    return [AuditoryDescription.create({ text: str })];
  }

  public initialize(): void {
    // Initialize Japanese store
  }

  public addRuleFunction(name: string, func: (node: Node) => string) {
    const dynamicCstr = this.parseCstr('default');
    const action = Action.fromString('{' + name + '}');
    const precondition = this.parsePrecondition(name, []);
    const rule = new SpeechRule(name, dynamicCstr, precondition, action);
    rule.context = this.context;
    this.context.customStrings.add('CSF' + name, (node: Node) => {
      return [Span.node(func(node), node as Element)];
    });
    this.addRule(rule);
  }
}

const japaneseStore = new JapaneseRuleStore();

// Register all rules
japaneseStore.addRuleFunction('FractionStartVerbose', startFractionVerbose);
japaneseStore.addRuleFunction('FractionEndVerbose', endFractionVerbose);
japaneseStore.addRuleFunction('FractionStartBrief', startFractionBrief);
japaneseStore.addRuleFunction('FractionEndBrief', endFractionBrief);
japaneseStore.addRuleFunction('FractionSimple', simpleFraction);
japaneseStore.addRuleFunction('FractionVulgar', vulgarFraction);
japaneseStore.addRuleFunction('RootExpression', rootExpression);
japaneseStore.addRuleFunction('Operator', operatorText);
japaneseStore.addRuleFunction('MatrixStart', matrixStart);
japaneseStore.addRuleFunction('MatrixEnd', matrixEnd);
japaneseStore.addRuleFunction('Subscript', subscript);
japaneseStore.addRuleFunction('Superscript', superscript);
japaneseStore.addRuleFunction('TrigFunction', trigFunction);

/**
 * Generates nested fraction in verbose mode.
 * @param node The node to process.
 * @param init Initial string.
 * @param frac Fraction string.
 * @returns The nested fraction string.
 */
function nestedFraction(node: any, init: string, frac: string) {
  const depth = node.xmlLength - 1;
  const annotation = [init];
  if (depth > 1) {
    annotation.push(
      LOCALE.FUNCTIONS.combineNestedFraction(
        LOCALE.FUNCTIONS.radicalNestDepth(depth - 1),
        LOCALE.MESSAGES.MS.NEST_FRAC,
        frac
      )
    );
  } else {
    annotation.push(frac);
  }
  return annotation.join(LOCALE.MESSAGES.regexp.JOINER_FRAC);
}

// Fraction handling functions
function startFractionVerbose(node: any) {
  return nestedFraction(node, LOCALE.MESSAGES.MS.START, LOCALE.MESSAGES.MS.FRAC_V);
}

function endFractionVerbose(node: any) {
  return nestedFraction(node, LOCALE.MESSAGES.MS.END, LOCALE.MESSAGES.MS.FRAC_V);
}

function startFractionBrief(node: any) {
  return nestedFraction(node, LOCALE.MESSAGES.MS.START, LOCALE.MESSAGES.MS.FRAC_B);
}

function endFractionBrief(node: any) {
  return nestedFraction(node, LOCALE.MESSAGES.MS.END, LOCALE.MESSAGES.MS.FRAC_B);
}

function simpleFraction(node: any) {
  const depth = node.xmlLength - 1;
  if (depth > 1) {
    return (
      LOCALE.MESSAGES.MS.FRAC_S +
      ' ' +
      LOCALE.FUNCTIONS.combineNestedFraction(
        LOCALE.FUNCTIONS.radicalNestDepth(depth - 1),
        LOCALE.MESSAGES.MS.NEST_FRAC,
        LOCALE.MESSAGES.MS.FRAC_S
      )
    );
  }
  return LOCALE.MESSAGES.MS.FRAC_S;
}

function vulgarFraction(node: any) {
  const children = node.childNodes;
  if (children.length !== 2) return '';
  const numerator = children[0].textContent;
  const denominator = children[1].textContent;
  return `${LOCALE.NUMBERS.numberToWords(parseInt(denominator))}分の${LOCALE.NUMBERS.numberToWords(parseInt(numerator))}`;
}

// Root expression handling
function rootExpression(node: any) {
  const children = node.childNodes;
  if (!children || children.length === 0) return '';
  
  let result = LOCALE.MESSAGES.MS.ROOT;
  if (children.length > 1) {
    // Has index
    const index = children[0].textContent;
    result = LOCALE.NUMBERS.numberToWords(parseInt(index)) + '乗根の';
  }
  return result + children[children.length - 1].textContent;
}

// Operator handling
function operatorText(node: any) {
  const text = node.textContent;
  const operators: { [key: string]: string } = {
    '+': 'たす',
    '-': 'ひく',
    '×': 'かける',
    '÷': 'わる',
    '=': 'イコール',
    '<': '小なり',
    '>': '大なり',
    '≤': '以下',
    '≥': '以上',
    '≠': '等しくない',
    '±': 'プラスマイナス',
    '∑': 'シグマ',
    '∏': 'パイ',
    '∫': '積分',
    '∂': '偏微分',
    '∞': '無限大',
    '∈': '属する',
    '∉': '属さない',
    '⊂': '部分集合',
    '⊃': '上位集合',
    '∪': '和集合',
    '∩': '共通部分',
    '∅': '空集合'
  };
  return operators[text] || text;
}

// Matrix handling
function matrixStart(node: any) {
  const rows = node.childNodes.length;
  const cols = node.childNodes[0].childNodes.length;
  return `${LOCALE.NUMBERS.numberToWords(rows)}行${LOCALE.NUMBERS.numberToWords(cols)}列の行列`;
}

function matrixEnd() {
  return '行列終わり';
}

// Subscript and superscript handling
function subscript(node: any) {
  return node.textContent + '下付き';
}

function superscript(node: any) {
  const text = node.textContent;
  const specialPowers: { [key: string]: string } = {
    '2': '二乗',
    '3': '三乗',
    'n': 'n乗',
    '-1': '逆数'
  };
  return specialPowers[text] || (text + '乗');
}

// Trigonometric functions
function trigFunction(node: any) {
  const text = node.textContent.toLowerCase();
  const functions: { [key: string]: string } = {
    'sin': 'サイン',
    'cos': 'コサイン',
    'tan': 'タンジェント',
    'sec': 'セカント',
    'csc': 'コセカント',
    'cot': 'コタンジェント',
    'arcsin': 'アークサイン',
    'arccos': 'アークコサイン',
    'arctan': 'アークタンジェント'
  };
  return functions[text] || text;
}

export const MathspeakJapanese = japaneseStore; 